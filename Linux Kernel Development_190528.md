# Linux Kernel Development

## Chapter 3. Process

프로세스는 프로그램 코드를 실행하면서 생기는 모든 결과물이라 할 수 있다.
리눅스는 프로세스와 스레드를 구분하지 않으며 스레드는 조금 특별한 형태로 구성된다.

현대 운영체제는 가상 프로세서와 가상 메모리라는 두가지 가상 환경을 제공한다.
이를 통해 실제 동작하는 프로세서가 여러개라도 하나의 프로세서가 사용하는 것 같은 환경을 제공한다. 스레드는 각자 고유한 가상 프로세서를 할당받지만 가상 메모리는 공유한다.

#### 프로세스 서술자와 태스크 구조체 

-------

커널은 프로세스 목록을 태스크 리스트라는 환형 양방향 연결 리스트형태로 저장한다
`struct task_struct`의 형식으로 구성되며 `<linux/sched.h>` 에 정의되어 있다.
이를 프로세스 서술자라 부른다. 32bit 시스템에서 1.7KB에 달한다. 이는 보통8KB의 스택 크기를 갖는 커널에서는 큰 구조체다.



#### 프로세스 생성

--------





#### 리눅스의 스레드 구현

--------





#### 프로세스 종료

-------

프로세스 종료는 exit() 함수가 호출되면서 진행된다. 
exit() 함수는 `kernel/exit.c`에 정의된 `do_exit()` 함수를 통해 진행된다.

> do_exit() 동작 순서
>
> 1. task_struct.flags : PF_EXITING flag set
> 2. del_timer_sync(): 커널 타이머 제거. 대기 중 및 실행 중인 타이머가 없어짐
>    -> 해당 프로세스에서 호출하는 인터럽트등이 없다는 것?
> 3. BSD 방식이라면 acct_updater_integrals() 함수를 호출하여 관련 정보 기록
> 4. exit_mm(): mm_struct 반환. 주소 공간이 공유되어 있지 않다면 자원 해제
> 5. exit_sem(): 세마포어 대기상태 해제
> 6. exit_files() & exit_fs() 호출: 파일 시스템의 참조횟수 -1. 0이 되면 자원 반환
> 7. 태스크 종료 코드를 task_struct의 exit_code 항목에 저장. 종료 코드 값 결정
> 8. exit_notify(): 부모 프로세스에 시그널을 보냄. init 프로세스를 자식 프로세스의 새로운 부모로 설정. task_struct 구조체의 exit_state 항목에 상태를 EXIT_ZOMBIE로 설정
> 9. schedule() 호출: 새로운 프로세스로 전환. 이 코드가 종료되는 태스크의 마지막 코드

##### 프로세스 서술자

프로세스는 종료되더라도 좀비상태로 남아 프로세스 서술자로 남는다. 시스템이 자식 프로세스의 정보를 얻게 하기 위함.

> wait()
>
> 기본동작: 함수를 호출한 프로세스의 동작을 자식 프로세스가 종료될 때까지 정지.
> 반환값은 자식 프로세스의 PID.

> release_task()
>
> ....

##### 부모 없는 태스크의 딜레마

부모 프로세스가 자식 프로세스보다 먼저 종료된 경우 다른 프로세스를 부모 프로세스로 지정한다. 이는 좀비 프로세스로 남아 시스템 메모리를 낭비하는 것을 방지하기 위함이다. 그래서 보통은 init 프로세스를 부모로 지정한다.

INIT 프로세스는 주기적으로 wait() 함수를 호출하여 자식 프로세스를 종료시킨다.

